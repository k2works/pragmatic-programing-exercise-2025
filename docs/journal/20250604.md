# 開発日誌

## 日付: 2025年6月4日

### 給与計算システムの実装と文書化

今日は給与計算システムの実装と文書化を行いました。リビジョン6d6c12461bb06f8b53808a81cf6cb8df24b65118からab174be33dce70b2944d1009d68b8208b9caa30cまでの変更内容をまとめます。

#### 実装された機能

1. **給与支払いスケジュールの実装**:
   - 月給制社員向けの月末支払い
   - 時給制社員向けの毎週金曜日支払い
   - 歩合制社員向けの隔週金曜日支払い

2. **給与計算ロジックの実装**:
   ```clojure
   ;; 固定給の社員の給与計算
   (defmethod calc-pay :salaried [employee]
     (let [salary (second (:pay-class employee))]
       salary))

   ;; 時給制の社員の給与計算
   (defmethod calc-pay :hourly [employee]
     (let [hourly-rate (second (:pay-class employee))
           db (:db employee)
           id (:id employee)
           time-cards (get-in db [:time-cards id])
           hours (if time-cards
                   (second (first time-cards))
                   0)]
       (* hours hourly-rate)))

   ;; 歩合制の社員の給与計算
   (defmethod calc-pay :commissioned [employee]
     (let [base-salary (second (:pay-class employee))
           commission-rate (nth (:pay-class employee) 2)
           db (:db employee)
           id (:id employee)
           sales-receipts (get-in db [:sales-receipts id])
           sales-amount (if sales-receipts
                          (second (first sales-receipts))
                          0)]
       (+ base-salary (* sales-amount commission-rate))))
   ```

3. **給与支払い方法の実装**:
   - 郵送による支払い
   - 銀行振込による支払い
   - 給与管理者経由の直接支払い

   ```clojure
   ;; 郵送による給与支払い
   (defmethod dispose :mail [paycheck-directive]
     (let [id (:id paycheck-directive)
           amount (:amount paycheck-directive)
           name (second (:disposition paycheck-directive))
           address (nth (:disposition paycheck-directive) 2)]
       {:type :mail
        :id id
        :name name
        :address address
        :amount amount}))
   ```

#### テスト実装

一連のコミットでは、給与計算システムの各コンポーネントに対するテストが実装されました。テストは以下の機能をカバーしています：

1. 給与支払いスケジュールの判定
2. 各種給与タイプ（固定給、時給制、歩合制）の計算
3. 各種支払い方法（郵送、銀行振込、給与管理者）の処理

#### 文書化

最終的なコミットでは、システムの詳細な文書化が行われました：

1. **システム概要**:
   - 給与計算システムの目的と設計原則
   - 関数型プログラミングアプローチの採用

2. **ドメインモデル**:
   ```mermaid
   classDiagram
       class Payroll {
           + payroll(today, db)
       }
       class Employee {
           + id
           + name
           + pay-class
           + schedule
           + disposition
       }
       class PayClassification{
           <<interface>>
           + calc-pay(employee)
       }
       %% 他のクラス定義は省略
   ```

3. **処理フロー**:
   ```mermaid
   sequenceDiagram
       participant Client
       participant Payroll
       participant Schedule
       participant Classification
       participant Disposition

       Client->>Payroll: payroll(today, db)
       Payroll->>Classification: get_employees(db)
       Classification-->>Payroll: employees
       %% 他のシーケンスは省略
   ```

4. **データモデル**と**処理例**:
   - 各種従業員タイプのデータ構造
   - 具体的な処理フローの例示

#### 所感

Clojureの関数型プログラミングアプローチとマルチメソッドを活用することで、給与計算システムの各コンポーネントが明確に分離され、拡張性の高い設計になっています。特に、データと振る舞いの分離により、システムの理解と保守が容易になっています。

今後の課題としては、より複雑な給与計算ルール（例：複数の時間帯での異なる時給、複数の歩合率など）への対応や、ユーザーインターフェースの実装が考えられます。

### 給与計算システムへのClojure Spec導入

今日はコミットf5401a0d02fa67180172c4aeb72bc4c96c281e49の内容を確認しました。このコミットでは給与計算システムにClojure Specを導入し、データ構造の検証と関数の仕様を明確化しています。

#### 実装された機能

1. **データ構造の仕様定義**:
   - 新しいファイル `payroll/specs.clj` が追加され、システム全体のデータ構造の仕様が定義されました
   - 主な定義内容:
      - データベース仕様 (従業員、タイムカード、売上記録)
      - 従業員仕様 (給与クラス、スケジュール、支払い方法)
      - 給与小切手仕様 (郵送、銀行振込、給与担当者)

   ```clojure
   ;; データベース仕様
   (s/def ::id integer?)
   (s/def ::name string?)
   (s/def ::employees (s/coll-of ::employee))
   (s/def ::time-cards (s/map-of ::id (s/coll-of (s/tuple any? number?))))
   (s/def ::sales-receipts (s/map-of ::id (s/coll-of (s/tuple any? number?))))
   (s/def ::db (s/keys :req-un [::employees]
                      :opt-un [::time-cards ::sales-receipts]))

   ;; 従業員仕様
   (s/def ::salaried-pay-class (s/tuple #{:salaried} number?))
   (s/def ::hourly-pay-class (s/tuple #{:hourly} number?))
   (s/def ::commissioned-pay-class (s/tuple #{:commissioned} number? number?))
   ```

2. **関数仕様の定義**:
   - 各モジュールの関数に対して `s/fdef` を使用して入力と出力の仕様を定義
   - 例:
     ```clojure
     ;; interface.clj
     (s/fdef calc-pay
       :args (s/cat :employee ::specs/employee)
       :ret ::specs/amount)

     ;; classification.clj
     (s/fdef get-employees
       :args (s/cat :db ::specs/db)
       :ret (s/coll-of ::specs/employee))
     ```

3. **モジュール間の一貫性確保**:
   - 全モジュール（interface.clj, classification.clj, disposition.clj, schedule.clj, payroll.clj）で一貫した仕様を使用
   - 各モジュールが `payroll.specs` を参照し、統一された型定義を使用

#### 導入の利点

1. **型安全性の向上**:
   - 実行時の型チェックにより、データ構造の不整合を早期に検出可能
   - 関数の入出力仕様が明確になり、誤用を防止

2. **ドキュメントとしての役割**:
   - コードを読むだけで各関数の期待される入力と出力が理解できる
   - データ構造の詳細な仕様がコード内に明示的に記述されている

3. **テスト自動化の基盤**:
   - 仕様に基づいた自動テスト生成（generative testing）が可能に
   - 境界条件やエッジケースの検出が容易になる

#### 次のステップ

1. Clojure Specを活用した自動テストの実装
2. 実行時の仕様チェック（instrumentation）の導入
3. より詳細な仕様（述語や条件）の追加

#### 所感

Clojure Specの導入により、給与計算システムの堅牢性と保守性が大幅に向上しました。静的型付け言語のような型安全性を得つつも、Clojureの柔軟性と表現力を維持できている点が素晴らしいです。

特に、マルチメソッドを使用した多態性の実装と組み合わせることで、型安全性と拡張性を両立させています。今後のシステム拡張時にも、仕様違反を早期に検出できるため、開発効率の向上が期待できます。

clojure.specの使い方について説明いたします。お使いのコードを参考に、実践的な使用例を含めてご説明します。

